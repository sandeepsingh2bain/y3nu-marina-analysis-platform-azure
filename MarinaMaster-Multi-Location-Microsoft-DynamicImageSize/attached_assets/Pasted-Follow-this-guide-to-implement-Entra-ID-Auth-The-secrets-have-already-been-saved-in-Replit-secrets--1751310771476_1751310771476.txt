Follow this guide to implement Entra ID Auth. The secrets have already been saved in Replit secrets.
Implementing Microsoft Entra ID (Azure AD) Authentication in a Node.js Express Application
This guide provides step-by-step instructions for implementing Microsoft Entra ID (formerly Azure AD) authentication in a Node.js Express application with React frontend. It uses the MSAL (Microsoft Authentication Library) for seamless single sign-on with Microsoft accounts.
Prerequisites
A Microsoft Entra ID (Azure AD) tenant
An app registration in the Microsoft Entra ID portal
PostgreSQL database for user and session storage
Required Environment Variables
ENTRA_CLIENT_ID=your_client_id_here
ENTRA_TENANT_ID=your_tenant_id_here
ENTRA_CLIENT_SECRET=your_client_secret_here
Step 1: Install Required Dependencies
npm install @azure/msal-node express-session cookie-parser connect-pg-simple
Step 2: Database Schema Setup
Ensure your user schema includes these fields:
// In schema.ts or equivalent
export const users = pgTable("users", {
id: serial("id").primaryKey(),
username: text("username").notNull().unique(),
displayName: text("display_name"),
email: text("email"),
entraId: text("entra_id").unique(),
role: text("role").default("PROJECT_USER"),
lastLogin: timestamp("last_login"),
});
Create a session table for storing authentication sessions:
CREATE TABLE session (
sid VARCHAR NOT NULL PRIMARY KEY,
sess JSON NOT NULL,
expire TIMESTAMP(6) NOT NULL
);
Step 3: Authentication Module (auth.ts)
Create
auth.ts
with the following structure:
import { Configuration, ConfidentialClientApplication, LogLevel, AccountInfo } from '@azure/msal-node';
import { Express, Request, Response, NextFunction } from 'express';
import session from 'express-session';
import cookieParser from 'cookie-parser';
import connectPg from 'connect-pg-simple';
import { storage } from './storage';
import { pool } from './db';
 
// MSAL configuration setup
const clientId = process.env.ENTRA_CLIENT_ID;
const tenantId = process.env.ENTRA_TENANT_ID;
const clientSecret = process.env.ENTRA_CLIENT_SECRET;
 
// Initialize MSAL client if credentials are available
let msalClient = null;
if (clientId && tenantId && clientSecret) {
try {
const msalConfig = {
auth: {
clientId,
authority: `
https://login.microsoftonline.com/${tenantId}`,
clientSecret,
},
system: {
loggerOptions: {
loggerCallback(loglevel, message) {
console.log(message);
},
piiLoggingEnabled: false,
logLevel: LogLevel.Info,
},
},
};
msalClient = new ConfidentialClientApplication(msalConfig);
console.log('[EntraID Auth] MSAL client initialized successfully');
} catch (error) {
console.error('[EntraID Auth] Failed to initialize MSAL client:', error);
msalClient = null;
}
}
 
// Set up session store
const PostgresSessionStore = connectPg(session);
const sessionStore = new PostgresSessionStore({
pool,
tableName: 'session',
createTableIfMissing: false,
});
 
// Configure auth routes and middleware
export function setupAuth(app: Express) {
// Session configuration
app.use(cookieParser());
app.use(session({
store: sessionStore,
secret: process.env.SESSION_SECRET || 'default-secret-change-in-production',
resave: false,
saveUninitialized: false,
cookie: {
secure: process.env.NODE_ENV === 'production',
maxAge: 24 * 60 * 60 * 1000, // 24 hours
}
}));
 
// Authentication Middleware
app.use((req, res, next) => {
if (req.session && req.session.account) {
req.user = {
id: req.session.userId || 0,
email: req.session.account.username || '',
displayName: req.session.account.name || '',
role: req.session.userRole || 'PROJECT_USER',
entraId: req.session.account.homeAccountId || '',
};
}
next();
});
 
// Login route
app.get("/auth/login", async (req, res) => {
if (!msalClient) {
return res.status(500).send("Microsoft authentication is not configured");
}
 
const appUrl = process.env.APP_URL || `https://${req.headers.host}`;
const authCodeUrlParameters = {
scopes: ["User.Read"],
redirectUri: `${appUrl}/auth/callback`,
};
 
try {
const authUrl = await msalClient.getAuthCodeUrl(authCodeUrlParameters);
res.redirect(authUrl);
} catch (error) {
console.error("Error during login:", error);
res.status(500).send("Error during login");
}
});
 
// Callback route
app.get("/auth/callback", async (req, res) => {
if (!msalClient) {
return res.status(500).send("Microsoft authentication is not configured");
}
 
const appUrl = process.env.APP_URL || `https://${req.headers.host}`;
const tokenRequest = {
code: req.query.code as string,
scopes: ["User.Read"],
redirectUri: `${appUrl}/auth/callback`,
};
 
try {
const response = await msalClient.acquireTokenByCode(tokenRequest);
if (!response.account) {
return res.status(500).send("No account information received");
}
 
// Store user in session
req.session.account = response.account;
req.session.accessToken = response.accessToken;
 
// Check if user exists in the database
const userFromDb = await storage.getUserByEntraId(response.account.homeAccountId);
 
if (userFromDb) {
// Update last login timestamp
await storage.updateUserLastLogin(userFromDb.id);
req.session.userId = userFromDb.id;
req.session.userRole = userFromDb.role || 'PROJECT_USER';
} else {
// Create new user
try {
const username = response.account.username ||
response.account.name?.replace(/\s+/g, '.').toLowerCase() ||
'user' + Date.now();
  
const newUser = await storage.createUser({
username,
displayName: response.account.name || '',
email: response.account.username || '',
entraId: response.account.homeAccountId,
role: 'PROJECT_USER',
});
req.session.userId = newUser.id;
req.session.userRole = 'PROJECT_USER';
} catch (error) {
console.error("Error creating user:", error);
return res.status(500).send("Error creating user account");
}
}
 
// Redirect to dashboard/home
res.redirect('/');
} catch (error) {
console.error("Error during token acquisition:", error);
res.status(500).send("Error during authentication");
}
});
 
// Logout route
app.get("/auth/logout", (req, res) => {
req.session.destroy(() => {
if (tenantId) {
const logoutUrl = `https://login.microsoftonline.com/${tenantId}/oauth2/v2.0/logout`;
res.redirect(logoutUrl);
} else {
res.redirect('/login');
}
});
});
 
// Authentication status endpoint
app.get("/api/auth/status", (req, res) => {
if (req.session && req.session.account) {
res.json({
authenticated: true,
user: {
id: req.session.userId,
displayName: req.session.account.name,
email: req.session.account.username,
role: req.session.userRole,
oid: req.session.account.localAccountId
}
});
} else {
res.json({ authenticated: false });
}
});
}
 
// Authentication middleware for protected routes
export function isAuthenticated(req, res, next) {
if (req.session && req.session.account) {
return next();
}
res.status(401).json({ message: "Unauthorized" });
}
Step 4: Add Storage Methods
Update your storage interface to include Entra ID-related methods:
// In storage.ts
interface IStorage {
// Existing methods...
 
// Entra ID related methods
getUserByEntraId(entraId: string): Promise<User | undefined>;
updateUserLastLogin(userId: number): Promise<void>;
}
 
// Implementation for database storage
async getUserByEntraId(entraId: string): Promise<User | undefined> {
const [user] = await db.select().from(users).where(eq(users.entraId, entraId));
return user;
}
 
async updateUserLastLogin(userId: number): Promise<void> {
await db.update(users)
.set({ lastLogin: new Date() })
.where(eq(users.id, userId));
}
Step 5: Set Up Frontend Authentication Context
Create
AuthContext.tsx for React frontend:
import React, { createContext, useContext, useEffect, useState } from 'react';
 
type User = {
id?: number;
displayName?: string;
email?: string;
role?: string;
oid?: string;
} | null;
 
interface AuthContextType {
user: User;
isAuthenticated: boolean;
isLoading: boolean;
logout: () => void;
}
 
const AuthContext = createContext<AuthContextType>({
user: null,
isAuthenticated: false,
isLoading: true,
logout: () => {},
});
 
export const AuthProvider = ({ children }: { children: React.ReactNode }) => {
const [user, setUser] = useState<User>(null);
const [isLoading, setIsLoading] = useState(true);
 
const checkAuth = async () => {
try {
const response = await fetch('/api/auth/status');
const data = await response.json();
 
if (data.authenticated && data.user) {
setUser(data.user);
} else {
setUser(null);
}
} catch (error) {
console.error('Auth check failed:', error);
setUser(null);
} finally {
setIsLoading(false);
}
};
 
useEffect(() => {
checkAuth();
}, []);
 
const logout = () => {
window.location.href = '/auth/logout';
};
 
return (
<AuthContext.Provider
value={{
user,
isAuthenticated: !!user,
isLoading,
logout,
}}
>
{children}
</AuthContext.Provider>
);
};
 
export const useAuth = () => {
const context = useContext(AuthContext);
if (!context) {
throw new Error("useAuth must be used within an AuthProvider");
}
return context;
};
Step 6: Create Protected Route Component
Create ProtectedRoute.tsx:
import React from 'react';
import { Route, Redirect } from 'wouter';
import { useAuth } from '@/contexts/AuthContext';
import { Loader2 } from 'lucide-react';
 
interface ProtectedRouteProps {
path: string;
component: React.ComponentType;
}
 
export function ProtectedRoute({ path, component: Component }: ProtectedRouteProps) {
const { isAuthenticated, isLoading } = useAuth();
 
return (
<Route path={path}>
{() => {
if (isLoading) {
return (
<div className="flex items-center justify-center min-h-screen">
<Loader2 className="h-8 w-8 animate-spin text-primary" />
</div>
);
}
 
if (!isAuthenticated) {
return <Redirect to="/login" />;
}
 
return <Component />;
}}
</Route>
);
}
Step 7: Create Login Page
Create a login page component:
import React, { useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { useAuth } from '@/contexts/AuthContext';
import { useLocation } from 'wouter';
 
export default function LoginPage() {
const { isAuthenticated, isLoading } = useAuth();
const [, navigate] = useLocation();
 
// Redirect if already logged in
useEffect(() => {
if (!isLoading && isAuthenticated) {
navigate('/');
}
}, [isAuthenticated, isLoading, navigate]);
 
return (
<div className="flex min-h-screen">
<div className="w-1/2 flex flex-col items-center justify-center p-8">
<div className="w-full max-w-md">
<h1 className="text-3xl font-bold mb-6">Application Name</h1>
<h2 className="text-xl mb-6">Sign in to continue</h2>
 
<p className="mb-8 text-gray-600">
Sign in with your Microsoft account to access the application.
</p>
 
<Button
onClick={() => window.location.href = '/auth/login'}
className="w-full"
>
Sign in with Microsoft
</Button>
</div>
</div>
 
<div className="w-1/2 bg-gradient-to-r from-blue-500 to-indigo-600 text-white flex items-center justify-center p-8">
<div className="max-w-md">
<h2 className="text-3xl font-bold mb-6">App Features</h2>
<p className="mb-4">
Description of your application and its features.
</p>
<ul className="space-y-2 mb-6">
<li className="flex items-center">
<span className="mr-2">✓</span> Feature 1
</li>
<li className="flex items-center">
<span className="mr-2">✓</span> Feature 2
</li>
<li className="flex items-center">
<span className="mr-2">✓</span> Feature 3
</li>
</ul>
</div>
</div>
</div>
);
}
Step 8: Setting Up Protected Routes in App
Update your main App component:
import { Switch, Route } from "wouter";
import { QueryClientProvider } from "@tanstack/react-query";
import { queryClient } from "./lib/queryClient";
import { AuthProvider } from "@/contexts/AuthContext";
import { ProtectedRoute } from "@/components/ProtectedRoute";
import HomePage from "@/pages/home-page";
import LoginPage from "@/pages/login-page";
import NotFound from "@/pages/not-found";
 
function Router() {
return (
<Switch>
<ProtectedRoute path="/" component={HomePage} />
{/* Add more protected routes as needed */}
<Route path="/login" component={LoginPage} />
<Route component={NotFound} />
</Switch>
);
}
 
function App() {
return (
<QueryClientProvider client={queryClient}>
<AuthProvider>
<Router />
</AuthProvider>
</QueryClientProvider>
);
}
 
export default App;
Step 9: Use Authentication in Express Routes
Apply the authentication middleware to your API routes:
// In routes.ts or server.ts
import { isAuthenticated } from './auth';
 
// Protected route example
app.get('/api/protected-resource', isAuthenticated, (req, res) => {
// Access user info via req.user
res.json({ data: 'This is protected data', user: req.user });
});
 
Important Notes
Use HTTPS for redirect URIs to match what's configured in Azure
Set up proper session storage to avoid conflicts
Implement error handling for missing credentials and authentication failures
Include detailed user onboarding and account creation logic.
 
o fix authentication issues:
Issue: PostgreSQL session store failed to serialize Entra ID session objects.
Fix: Replaced PostgreSQL session store with memorystore (in-memory), which supports serialization.
Session Config: Updated session settings to align with Replit’s environment (e.g., proper cookie options).
Client Sync: Modified client code to check authentication status with the server before rendering pages.
Callback Flow: Simplified the auth callback to reliably save sessions before redirecting to the home page.
 
There will be multiple hostname urls for this app (preview, prod). The auth needs to work for any hostname url. After authenticating with microsoft from /login it should redirect to the homepage of the app using the original hostname url. It should not redirect back to /login after a successful login.